<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shader Art Coding â€” Interactive Tutorial</title>
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CSS Reset & Base
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --bg:        #0d1117;
  --bg-panel:  #161b22;
  --bg-dark:   #010409;
  --bg-editor: #0d1117;
  --border:    #30363d;
  --text:      #e6edf3;
  --text-dim:  #8b949e;
  --text-dimmer:#484f58;
  --accent:    #58a6ff;
  --accent2:   #3fb950;
  --accent3:   #d2a8ff;
  --accent4:   #f78166;
  --accent5:   #ff7b72;
  --yellow:    #e3b341;
  --radius:    8px;
  --transition: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  --tutorial-width: 420px;
  --header-h: 48px;
}
html, body { height: 100%; overflow: hidden; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  display: flex;
  flex-direction: column;
}
::selection { background: rgba(88,166,255,0.3); }
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Header
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#header {
  height: var(--header-h);
  background: var(--bg-dark);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 12px;
  flex-shrink: 0;
  z-index: 100;
}
#header .logo {
  font-weight: 700;
  font-size: 15px;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
  white-space: nowrap;
}
#header .logo span { font-size: 18px; }
.header-sep { width: 1px; height: 24px; background: var(--border); }
.btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 14px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: var(--bg-panel);
  color: var(--text);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition);
  white-space: nowrap;
  user-select: none;
}
.btn:hover { background: var(--border); border-color: var(--text-dim); }
.btn.primary { background: #238636; border-color: #2ea043; color: #fff; }
.btn.primary:hover { background: #2ea043; }
.btn.danger { border-color: var(--accent5); color: var(--accent5); }
.btn.danger:hover { background: rgba(255,123,114,0.15); }
.btn.active { background: rgba(88,166,255,0.15); border-color: var(--accent); color: var(--accent); }
.header-right { margin-left: auto; display: flex; align-items: center; gap: 8px; }
.hud { font-size: 12px; color: var(--text-dim); display: flex; gap: 12px; }
.hud .val { color: var(--accent2); font-weight: 600; font-variant-numeric: tabular-nums; }
#lesson-select {
  background: var(--bg-panel);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 5px 28px 5px 10px;
  font-size: 13px;
  cursor: pointer;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238b949e' d='M2.5 4.5L6 8l3.5-3.5'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 8px center;
}
#lesson-select:hover { border-color: var(--text-dim); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Main Layout
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#main {
  flex: 1;
  display: flex;
  overflow: hidden;
  position: relative;
}

/* â”€â”€ Tutorial Panel â”€â”€ */
#tutorial-panel {
  width: var(--tutorial-width);
  min-width: var(--tutorial-width);
  background: var(--bg-panel);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  transition: margin-left var(--transition), opacity var(--transition);
  z-index: 50;
}
#tutorial-panel.hidden {
  margin-left: calc(-1 * var(--tutorial-width));
  opacity: 0;
  pointer-events: none;
}
#tutorial-header {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}
#tutorial-header h2 {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
}
#tutorial-body {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}
/* Lesson navigation pills in tutorial */
#lesson-pills {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-bottom: 16px;
}
.pill {
  padding: 3px 10px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--text-dim);
  cursor: pointer;
  transition: all var(--transition);
}
.pill:hover { border-color: var(--accent); color: var(--accent); }
.pill.active { background: rgba(88,166,255,0.15); border-color: var(--accent); color: var(--accent); }
.pill.completed { border-color: var(--accent2); color: var(--accent2); }
.pill.completed::before { content: "âœ“ "; }

/* Tutorial rich content */
.tutorial-content { animation: fadeIn 0.3s ease; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: none; } }
.tutorial-content h1 {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 4px;
  background: linear-gradient(135deg, var(--accent), var(--accent3));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.tutorial-content .subtitle {
  font-size: 13px;
  color: var(--text-dim);
  margin-bottom: 20px;
}
.tutorial-content h2 {
  font-size: 15px;
  font-weight: 600;
  color: var(--accent);
  margin: 20px 0 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.tutorial-content h3 {
  font-size: 13px;
  font-weight: 600;
  color: var(--accent3);
  margin: 16px 0 6px;
}
.tutorial-content p { margin-bottom: 12px; color: var(--text); font-size: 13.5px; }
.tutorial-content ul, .tutorial-content ol { margin: 0 0 12px 20px; font-size: 13.5px; }
.tutorial-content li { margin-bottom: 4px; }
.tutorial-content code {
  background: rgba(88,166,255,0.1);
  color: var(--accent);
  padding: 1px 6px;
  border-radius: 4px;
  font-family: 'Consolas', 'Fira Code', 'Courier New', monospace;
  font-size: 12.5px;
}
.tutorial-content pre {
  background: var(--bg-dark);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  margin-bottom: 12px;
  overflow-x: auto;
  font-family: 'Consolas', 'Fira Code', 'Courier New', monospace;
  font-size: 12.5px;
  line-height: 1.5;
  color: var(--text);
}
.tutorial-content .tip {
  background: rgba(63,185,80,0.08);
  border-left: 3px solid var(--accent2);
  padding: 10px 14px;
  border-radius: 0 6px 6px 0;
  margin-bottom: 12px;
  font-size: 13px;
}
.tutorial-content .tip::before { content: "ğŸ’¡ "; }
.tutorial-content .warn {
  background: rgba(227,179,65,0.08);
  border-left: 3px solid var(--yellow);
  padding: 10px 14px;
  border-radius: 0 6px 6px 0;
  margin-bottom: 12px;
  font-size: 13px;
}
.tutorial-content .warn::before { content: "âš ï¸ "; }
.tutorial-content .exercise {
  background: rgba(210,168,255,0.08);
  border: 1px solid rgba(210,168,255,0.2);
  border-radius: 6px;
  padding: 12px 14px;
  margin-bottom: 10px;
}
.tutorial-content .exercise-title {
  font-weight: 600;
  color: var(--accent3);
  font-size: 13px;
  margin-bottom: 4px;
}
.tutorial-content .nav-buttons {
  display: flex;
  gap: 8px;
  margin-top: 24px;
  padding-top: 16px;
  border-top: 1px solid var(--border);
}
.tutorial-content .nav-buttons .btn { flex: 1; justify-content: center; }
.tutorial-content table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 12px;
  font-size: 13px;
}
.tutorial-content th, .tutorial-content td {
  padding: 6px 10px;
  border: 1px solid var(--border);
  text-align: left;
}
.tutorial-content th { background: var(--bg-dark); color: var(--accent); font-weight: 600; }

/* â”€â”€ Workspace (editor + canvas) â”€â”€ */
#workspace {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
}
#workspace-split {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* Editor area */
#editor-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 200px;
  border-right: 1px solid var(--border);
}
#editor-tabs {
  display: flex;
  align-items: center;
  background: var(--bg-dark);
  border-bottom: 1px solid var(--border);
  padding: 0 8px;
  height: 36px;
  flex-shrink: 0;
}
.tab {
  padding: 6px 14px;
  font-size: 12px;
  color: var(--text-dim);
  border-bottom: 2px solid transparent;
  cursor: default;
  display: flex;
  align-items: center;
  gap: 6px;
}
.tab.active { color: var(--text); border-bottom-color: var(--accent); }
.tab .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent4); }
#shader-code {
  flex: 1;
  background: var(--bg-editor);
  color: var(--text);
  font-family: 'Consolas', 'Fira Code', 'Courier New', monospace;
  font-size: 13px;
  line-height: 1.65;
  padding: 12px 16px;
  border: none;
  resize: none;
  outline: none;
  tab-size: 4;
  white-space: pre;
  overflow: auto;
  caret-color: var(--accent);
}
#error-bar {
  background: rgba(248,97,102,0.08);
  color: var(--accent5);
  font-family: 'Consolas', monospace;
  font-size: 12px;
  padding: 8px 14px;
  max-height: 80px;
  overflow-y: auto;
  display: none;
  white-space: pre-wrap;
  border-top: 1px solid rgba(248,97,102,0.3);
}

/* Canvas area */
#canvas-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 200px;
  background: #000;
}
#canvas-bar {
  display: flex;
  align-items: center;
  padding: 0 12px;
  height: 36px;
  background: var(--bg-dark);
  border-bottom: 1px solid var(--border);
  gap: 12px;
  flex-shrink: 0;
}
#canvas-bar .label { font-size: 12px; color: var(--text-dim); }
#canvas-bar .val { color: var(--accent2); font-weight: 600; font-size: 12px; }
canvas {
  flex: 1;
  width: 100%;
  display: block;
  cursor: crosshair;
}

/* Resizer */
#resizer {
  width: 4px;
  cursor: col-resize;
  background: var(--border);
  transition: background var(--transition);
  flex-shrink: 0;
}
#resizer:hover, #resizer.active { background: var(--accent); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Responsive
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
@media (max-width: 900px) {
  :root { --tutorial-width: 320px; }
}
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/theme.css">
  <link rel="stylesheet" href="css/components.css">
  <link rel="stylesheet" href="css/lesson.css">

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HEADER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="header">
  <div class="logo"><span>âœ¦</span> Shader Art Coding</div>
  <div class="header-sep"></div>
  <button class="btn active" id="btn-tutorial" title="Toggle tutorial panel (T)">ğŸ“– Tutorial</button>
  <select id="lesson-select"></select>
  <div class="header-sep"></div>
  <button class="btn primary" id="btn-compile" title="Compile shader (Ctrl+Enter)">â–¶ Run</button>
  <button class="btn" id="btn-pause" title="Pause/resume (Space)">â¸ Pause</button>
  <button class="btn" id="btn-reset" title="Reset time">â†º Reset</button>
  <div class="header-right">
    <div class="hud">
      <span>Time: <span class="val" id="hud-time">0.00</span>s</span>
      <span>FPS: <span class="val" id="hud-fps">0</span></span>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="main">

  <!-- Tutorial Panel -->
  <div id="tutorial-panel">
    <div id="tutorial-header">
      <h2>ğŸ“– Lessons</h2>
      <button class="btn" id="btn-close-tutorial" style="padding:3px 8px;font-size:11px;">âœ• Close</button>
    </div>
    <div id="tutorial-body">
      <div id="lesson-pills"></div>
      <div id="tutorial-content" class="tutorial-content"></div>
    </div>
  </div>

  <!-- Workspace -->
  <div id="workspace">
    <div id="workspace-split">
      <!-- Code Editor -->
      <div id="editor-area">
        <div id="editor-tabs">
          <div class="tab active"><div class="dot"></div><span id="tab-filename">shader.glsl</span></div>
        </div>
        <textarea id="shader-code" spellcheck="false"></textarea>
        <div id="error-bar"></div>
      </div>

      <!-- Resizer -->
      <div id="resizer"></div>

      <!-- Canvas -->
      <div id="canvas-area">
        <div id="canvas-bar">
          <span class="label">Resolution:</span>
          <span class="val" id="hud-res">0Ã—0</span>
          <span class="label" style="margin-left:8px;">Mouse:</span>
          <span class="val" id="hud-mouse">0, 0</span>
        </div>
        <canvas id="glcanvas"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ALL LESSON DATA â€” Tutorial text + shader code, fully inline
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const LESSONS = [
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 0: Welcome â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "Welcome",
  short: "Intro",
  tutorial: `
<h1>Welcome to Shader Art Coding</h1>
<p class="subtitle">A hands-on journey into the language of Shadertoy</p>

<h2>ğŸ¯ What is this?</h2>
<p>This is an interactive tutorial that teaches you <strong>GLSL shader programming</strong> â€” the same language used on <a href="https://shadertoy.com" target="_blank" style="color:var(--accent)">Shadertoy.com</a>, the world's most popular platform for shader art.</p>
<p>You'll go from zero to creating animated 3D scenes, all with pure math â€” no 3D models, no textures, just code.</p>

<h2>ğŸ–¥ï¸ How to use this</h2>
<ul>
  <li><strong>Left panel</strong> (this one): Lessons, explanations, exercises</li>
  <li><strong>Middle</strong>: Code editor â€” edit the shader code here</li>
  <li><strong>Right</strong>: Live canvas â€” see your shader running in real time</li>
</ul>

<div class="tip">Press <code>Ctrl+Enter</code> to compile your code after making changes. Or click the green <strong>â–¶ Run</strong> button.</div>

<h2>ğŸ“ What is a shader?</h2>
<p>A shader is a tiny program that runs <strong>once for every pixel on the screen</strong>, every frame. You write a single function:</p>
<pre>void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Your code here â€” decide what color this pixel should be!
    fragColor = vec4(1.0, 0.0, 0.0, 1.0); // red
}</pre>
<p>That's it. The GPU runs this function millions of times in parallel â€” one per pixel â€” giving you real-time graphics at 60fps.</p>

<h2>ğŸ—‚ï¸ Lesson Roadmap</h2>
<table>
<tr><th>#</th><th>Topic</th><th>You'll Learn</th></tr>
<tr><td>01</td><td>Hello Color</td><td>UV coordinates, colors, gradients</td></tr>
<tr><td>02</td><td>Shapes</td><td>Signed Distance Functions (SDFs)</td></tr>
<tr><td>03</td><td>Transforms</td><td>Translate, rotate, scale</td></tr>
<tr><td>04</td><td>Animation</td><td>Using time, easing, motion</td></tr>
<tr><td>05</td><td>Patterns</td><td>Tiling, grids, repetition</td></tr>
<tr><td>06</td><td>Color</td><td>Palettes, HSV, gradients</td></tr>
<tr><td>07</td><td>Noise</td><td>Organic textures, FBM</td></tr>
<tr><td>08</td><td>Raymarching</td><td>3D scenes from math</td></tr>
<tr><td>09</td><td>Lighting</td><td>Shadows, reflections, AO</td></tr>
<tr><td>10</td><td>Advanced SDF</td><td>Booleans, fractals, polish</td></tr>
</table>

<h2>ğŸ”‘ GLSL Quick Reference</h2>
<table>
<tr><th>Type</th><th>Example</th><th>Notes</th></tr>
<tr><td><code>float</code></td><td><code>0.5</code></td><td>Always use decimal point!</td></tr>
<tr><td><code>vec2</code></td><td><code>vec2(1.0, 2.0)</code></td><td>2D vector (positions, UVs)</td></tr>
<tr><td><code>vec3</code></td><td><code>vec3(r, g, b)</code></td><td>3D vector / RGB color</td></tr>
<tr><td><code>vec4</code></td><td><code>vec4(col, 1.0)</code></td><td>RGBA output color</td></tr>
<tr><td><code>mat2</code></td><td><code>mat2(c,-s,s,c)</code></td><td>2Ã—2 rotation matrix</td></tr>
</table>

<h2>ğŸŒ Shadertoy Uniforms</h2>
<p>These are provided automatically â€” use them in your code:</p>
<table>
<tr><th>Uniform</th><th>Type</th><th>What it is</th></tr>
<tr><td><code>iResolution</code></td><td>vec3</td><td>Canvas width, height, 1.0</td></tr>
<tr><td><code>iTime</code></td><td>float</td><td>Seconds since start</td></tr>
<tr><td><code>iTimeDelta</code></td><td>float</td><td>Time since last frame</td></tr>
<tr><td><code>iFrame</code></td><td>int</td><td>Frame counter</td></tr>
<tr><td><code>iMouse</code></td><td>vec4</td><td>Mouse position &amp; click</td></tr>
</table>

<div class="tip">Click <strong>"01 Hello"</strong> above or select Lesson 01 from the dropdown to start!</div>
  `,
  code: `// Welcome! Click "01 Hello" in the tutorial panel to start.
// Or just play with this shader:

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Normalize pixel coordinates to 0..1
    vec2 uv = fragCoord / iResolution.xy;

    // Create a colorful gradient
    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));

    // Output
    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 1: Hello Color â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "01 â€” Hello Color",
  short: "01 Hello",
  tutorial: `
<h1>Hello Color</h1>
<p class="subtitle">UV coordinates, vectors, and your first gradient</p>

<h2>ğŸ¯ Goal</h2>
<p>Understand how pixels become colors. This is the foundation of everything.</p>

<h2>ğŸ“ The Coordinate System</h2>
<p>Every pixel has a position <code>fragCoord</code> in pixels (e.g. 640, 360). But we want resolution-independent code, so we <strong>normalize</strong> to 0â†’1:</p>
<pre>vec2 uv = fragCoord / iResolution.xy;</pre>
<p>Now <code>uv.x</code> goes 0 (left) â†’ 1 (right), and <code>uv.y</code> goes 0 (bottom) â†’ 1 (top).</p>

<h2>ğŸ¨ Colors in GLSL</h2>
<p>Colors are <code>vec3(red, green, blue)</code> with each channel from <strong>0.0</strong> (none) to <strong>1.0</strong> (full):</p>
<pre>vec3(1.0, 0.0, 0.0)  // pure red
vec3(0.0, 1.0, 0.0)  // pure green
vec3(0.0, 0.0, 1.0)  // pure blue
vec3(1.0, 1.0, 1.0)  // white
vec3(0.0)             // black (shorthand)</pre>

<h2>â­ The Most Important Function: <code>mix()</code></h2>
<p><code>mix(a, b, t)</code> = linear interpolation. When t=0 you get a, when t=1 you get b, t=0.5 is halfway.</p>
<pre>mix(vec3(1,0,0), vec3(0,0,1), uv.x)
// Red on left, blue on right, purple in between!</pre>

<h2>ğŸ“ Centered Coordinates</h2>
<p>For most shader art, you want (0,0) at the <strong>center</strong> and correct aspect ratio:</p>
<pre>vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;</pre>
<p>This is the <strong>standard setup</strong> you'll use in almost every shader from here on.</p>

<div class="warn">Note: we divide by <code>iResolution.y</code> (not <code>.xy</code>) â€” this keeps the aspect ratio square so circles don't stretch.</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1 â€” Solid Color</div>
<p>Replace the <code>col</code> line with: <code>vec3 col = vec3(1.0, 0.0, 0.0);</code> and compile. Pure red!</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2 â€” Horizontal Gradient</div>
<p>Try: <code>vec3 col = vec3(uv.x);</code> â€” black on left, white on right.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 3 â€” Two-Color Gradient</div>
<p>Use mix: <code>vec3 col = mix(vec3(1,0,0), vec3(0,0,1), uv.x);</code></p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 4 â€” Centered Coordinates</div>
<p>Change the UV line to the centered version and try <code>vec3 col = vec3(length(uv));</code> â€” you'll see a radial gradient!</p>
</div>

<div class="tip">After each change, press <code>Ctrl+Enter</code> to see the result. Experiment freely â€” you can always click "01 Hello" to reset the code!</div>
  `,
  code: `// LESSON 01 â€” Hello Color
// Your first shader! Change values and press Ctrl+Enter.

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Step 1: Normalize pixel coordinates to 0.0 â†’ 1.0
    vec2 uv = fragCoord / iResolution.xy;

    // Step 2: Create a color using UV coordinates
    // uv.x = 0 on left, 1 on right
    // uv.y = 0 on bottom, 1 on top
    vec3 col = vec3(uv.x, uv.y, 0.5);

    // TRY THESE (replace the line above):
    // vec3 col = vec3(1.0, 0.0, 0.0);             // solid red
    // vec3 col = vec3(uv.x);                       // horizontal gradient
    // vec3 col = mix(vec3(1,0,0), vec3(0,0,1), uv.x); // redâ†’blue

    // Step 3: Output the color (alpha = 1.0 = fully opaque)
    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 2: Shapes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "02 â€” Shapes (SDFs)",
  short: "02 Shapes",
  tutorial: `
<h1>Shapes with SDFs</h1>
<p class="subtitle">Signed Distance Functions â€” drawing with pure math</p>

<h2>ğŸ¯ Goal</h2>
<p>Learn Signed Distance Functions (SDFs), the core technique of shader art.</p>

<h2>ğŸ“ What is an SDF?</h2>
<p>An SDF is a function that takes a point and returns the <strong>distance to the nearest surface</strong>:</p>
<ul>
  <li><strong>Positive</strong> â†’ outside the shape</li>
  <li><strong>Zero</strong> â†’ exactly on the boundary</li>
  <li><strong>Negative</strong> â†’ inside the shape</li>
</ul>

<h2>â­• SDF: Circle</h2>
<p>The simplest SDF â€” distance from center minus radius:</p>
<pre>float sdCircle(vec2 p, float r) {
    return length(p) - r;
}</pre>
<p>When <code>length(p) < r</code>, we're inside â†’ negative. Beautiful!</p>

<h2>â—¼ SDF: Box</h2>
<pre>float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0))
         + min(max(d.x, d.y), 0.0);
}</pre>
<p>Uses <code>abs()</code> for symmetry â€” one formula handles all 4 sides!</p>

<h2>ğŸ¨ Drawing SDFs: smoothstep</h2>
<p><code>smoothstep(a, b, x)</code> returns 0 when x&lt;a, 1 when x&gt;b, smooth curve between.</p>
<p>We use it to turn distance into a crisp, antialiased shape:</p>
<pre>float d = sdCircle(uv, 0.25);
float shape = 1.0 - smoothstep(0.0, 0.008, d);
col = mix(background, shapeColor, shape);</pre>

<h2>ğŸ”— CSG: Combining Shapes</h2>
<p>This is where SDFs get POWERFUL:</p>
<pre>min(a, b)      // Union (combine)
max(a, b)      // Intersection (overlap only)
max(a, -b)     // Subtraction (cut b from a)</pre>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1</div>
<p>Change the circle radius (<code>0.25</code>) and box size. Observe how the SDF works.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2</div>
<p>Move shapes by changing their offset: <code>uv - vec2(0.3, 0.1)</code></p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 3 â€” CSG Subtraction</div>
<p>Try: <code>float d = max(sdCircle(uv, 0.3), -sdBox(uv, vec2(0.15)));</code></p>
<p>This cuts a square hole in a circle!</p>
</div>

<div class="tip">SDFs are used for EVERYTHING in shader art â€” 2D shapes, 3D raymarching, text, terrain. Master them and you can create anything.</div>
  `,
  code: `// LESSON 02 â€” Shapes with Signed Distance Functions

// SDF: Circle â€” distance from center minus radius
float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

// SDF: Box â€” uses abs() for symmetry
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// SDF: Ring
float sdRing(vec2 p, float r, float thickness) {
    return abs(length(p) - r) - thickness;
}

// SDF: Line segment
float sdSegment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Centered UV â€” the standard setup
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;

    // Background
    vec3 col = vec3(0.05 + 0.03 * uv.y);

    // Circle at center
    float d = sdCircle(uv, 0.25);
    float shape = 1.0 - smoothstep(0.0, 0.008, d);
    col = mix(col, vec3(0.2, 0.6, 1.0), shape);

    // Box to the right
    d = sdBox(uv - vec2(0.5, 0.0), vec2(0.12, 0.12));
    shape = 1.0 - smoothstep(0.0, 0.008, d);
    col = mix(col, vec3(1.0, 0.3, 0.4), shape);

    // Ring on the left
    d = sdRing(uv + vec2(0.5, 0.0), 0.15, 0.02);
    shape = 1.0 - smoothstep(0.0, 0.008, d);
    col = mix(col, vec3(0.3, 1.0, 0.5), shape);

    // Line at bottom
    d = sdSegment(uv, vec2(-0.3, -0.3), vec2(0.3, -0.3)) - 0.005;
    shape = 1.0 - smoothstep(0.0, 0.008, d);
    col = mix(col, vec3(1.0, 0.9, 0.2), shape);

    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 3: Transformations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "03 â€” Transformations",
  short: "03 Transform",
  tutorial: `
<h1>Transformations</h1>
<p class="subtitle">Translate, rotate, and scale â€” by moving space, not shapes</p>

<h2>ğŸ¯ Key Insight</h2>
<p>In shader land, you don't move shapes â€” you move the <strong>coordinate system</strong>. And it works in <strong>reverse</strong>:</p>
<ul>
  <li>To move a shape <strong>right</strong> â†’ <strong>subtract</strong> from coordinates</li>
  <li>To make a shape <strong>bigger</strong> â†’ <strong>divide</strong> coordinates</li>
  <li>To rotate a shape <strong>clockwise</strong> â†’ rotate coords <strong>counter-clockwise</strong></li>
</ul>
<p>Why? Because for each pixel we ask: "In the shape's local space, where would this point be?"</p>

<h2>ğŸ“ Translation</h2>
<pre>vec2 p = uv - vec2(0.3, 0.2);  // move shape to (0.3, 0.2)
float d = sdCircle(p, 0.1);</pre>

<h2>ğŸ”„ Rotation</h2>
<p>The 2D rotation matrix â€” memorize this, you'll use it constantly:</p>
<pre>mat2 rot2D(float angle) {
    float c = cos(angle), s = sin(angle);
    return mat2(c, -s, s, c);
}

vec2 p = rot2D(iTime) * uv; // spin!</pre>

<h2>ğŸ“ Scale</h2>
<pre>float scale = 2.0;
vec2 p = uv / scale;
float d = sdCircle(p, 0.1) * scale; // fix distance!</pre>
<div class="warn">When scaling SDFs, multiply the result by the scale factor to keep distances correct.</div>

<h2>ğŸª Combining Transforms</h2>
<p>Order matters! Translate first, then rotate = orbit. Rotate first, then translate = rotate in place then shift.</p>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1</div>
<p>Change the rotation speed: multiply <code>iTime</code> by different values.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2</div>
<p>Add more shapes to the orbit â€” change <code>6.0</code> to <code>12.0</code>.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 3</div>
<p>Make the orbit radius pulse: <code>0.25 + 0.1 * sin(iTime * 2.0)</code></p>
</div>
  `,
  code: `// LESSON 03 â€” Transformations

float sdCircle(vec2 p, float r) { return length(p) - r; }
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// 2D Rotation matrix â€” memorize this!
mat2 rot2D(float a) {
    float c = cos(a), s = sin(a);
    return mat2(c, -s, s, c);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    vec3 col = vec3(0.05);

    // 1. TRANSLATION â€” shift the coordinate system
    {
        vec2 p = uv - vec2(-0.5, 0.2);
        float d = sdCircle(p, 0.1);
        col = mix(col, vec3(0.2, 0.6, 1.0), 1.0 - smoothstep(0.0, 0.008, d));
    }

    // 2. ROTATION â€” multiply by rotation matrix
    {
        vec2 p = uv - vec2(0.0, 0.2);
        p = rot2D(iTime) * p;  // animated rotation!
        float d = sdBox(p, vec2(0.08));
        col = mix(col, vec3(1.0, 0.3, 0.5), 1.0 - smoothstep(0.0, 0.008, d));
    }

    // 3. SCALE â€” divide coords, correct SDF distance
    {
        vec2 p = uv - vec2(0.5, 0.2);
        float scale = 1.5 + 0.5 * sin(iTime);
        p /= scale;
        float d = sdCircle(p, 0.1) * scale;
        col = mix(col, vec3(0.3, 1.0, 0.5), 1.0 - smoothstep(0.0, 0.008, d));
    }

    // 4. COMBINED â€” Orbiting squares!
    {
        for (float i = 0.0; i < 6.0; i++) {
            float angle = iTime * 0.8 + i * 6.28318 / 6.0;
            float radius = 0.25;
            vec2 p = uv - vec2(0.0, -0.3);
            p -= radius * vec2(cos(angle), sin(angle));
            p = rot2D(angle * 2.0) * p;
            float d = sdBox(p, vec2(0.03));
            vec3 c = 0.5 + 0.5 * cos(vec3(0, 2, 4) + i * 0.8);
            col = mix(col, c, 1.0 - smoothstep(0.0, 0.008, d));
        }
    }

    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 4: Animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "04 â€” Animation",
  short: "04 Animate",
  tutorial: `
<h1>Animation</h1>
<p class="subtitle">Bringing shaders to life with time</p>

<h2>ğŸ¯ The Secret</h2>
<p>Everything in shader animation comes from <strong>one variable</strong>: <code>iTime</code> â€” seconds since the shader started.</p>

<h2>âš¡ Essential Functions</h2>
<table>
<tr><th>Expression</th><th>Result</th></tr>
<tr><td><code>sin(iTime)</code></td><td>Smooth oscillation -1 â†’ +1</td></tr>
<tr><td><code>sin(iTime)*0.5+0.5</code></td><td>Remap to 0 â†’ 1</td></tr>
<tr><td><code>fract(iTime)</code></td><td>Sawtooth: 0â†’1, 0â†’1, ...</td></tr>
<tr><td><code>abs(sin(iTime))</code></td><td>Bounce (always positive)</td></tr>
<tr><td><code>sin(iTime + offset)</code></td><td>Phase offset (stagger)</td></tr>
<tr><td><code>sin(iTime + uv.x * freq)</code></td><td>Traveling wave!</td></tr>
</table>

<h2>ğŸ Easing Functions</h2>
<p>Map linear 0â†’1 to curved 0â†’1 for natural-feeling motion:</p>
<pre>// Smooth in-out
float easeInOut(float t) {
    return t * t * (3.0 - 2.0 * t);
}

// Bouncy landing
float easeBounce(float t) {
    // ...see code
}</pre>

<h2>ğŸŒŠ Traveling Waves</h2>
<p>Offset the phase by position to create waves:</p>
<pre>float wave = sin(uv.x * 15.0 - iTime * 4.0) * 0.05;</pre>
<p>Each column oscillates, but shifted in time â†’ wave motion!</p>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1</div>
<p>Change the wave speed (the <code>4.0</code> multiplier) and frequency (<code>15.0</code>).</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2 â€” Heartbeat</div>
<p>Try a sharp pulse: <code>float pulse = pow(fract(-iTime), 10.0);</code></p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 3 â€” Stagger More</div>
<p>Change the number of circles and the delay between them.</p>
</div>
  `,
  code: `// LESSON 04 â€” Animation

float sdCircle(vec2 p, float r) { return length(p) - r; }
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}
mat2 rot2D(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }

// Easing: smooth in-out
float easeInOut(float t) { return t * t * (3.0 - 2.0 * t); }
// Easing: bouncy
float easeBounce(float t) {
    t = 1.0 - t;
    return 1.0 - abs(sin(t * 3.14159 * (0.2 + 2.5*t*t*t)) * pow(1.0-t, 2.2));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    vec3 col = vec3(0.02, 0.02, 0.05);

    // 1. PULSING GLOW
    {
        float pulse = 0.15 + 0.05 * sin(iTime * 3.0);
        float d = sdCircle(uv - vec2(-0.6, 0.25), pulse);
        float glow = exp(-8.0 * max(d, 0.0));
        col += vec3(0.2, 0.5, 1.0) * glow;
    }

    // 2. TRAVELING WAVE
    {
        float wave = sin(uv.x * 15.0 - iTime * 4.0) * 0.05;
        float d = abs(uv.y - wave) - 0.003;
        col += vec3(0.0, 1.0, 0.6) * (1.0 - smoothstep(0.0, 0.008, d));
    }

    // 3. BOUNCING BALL
    {
        float t = fract(iTime * 0.5);
        float y = easeBounce(t) * 0.4 - 0.2;
        float d = sdCircle(uv - vec2(-0.2, y), 0.04);
        col = mix(col, vec3(1.0, 0.4, 0.2), 1.0 - smoothstep(0.0, 0.008, d));
    }

    // 4. STAGGERED DOTS
    {
        for (float i = 0.0; i < 8.0; i++) {
            float delay = i * 0.15;
            float t = easeInOut(fract(iTime * 0.7 - delay));
            float x = mix(-0.4, 0.4, i / 7.0);
            float y = -0.35 + t * 0.15;
            float d = sdCircle(uv - vec2(x, y), 0.02 + 0.01*sin(iTime*2.0+i));
            vec3 c = 0.5 + 0.5 * cos(vec3(0,2,4) + i*0.5 + iTime);
            col = mix(col, c, 1.0 - smoothstep(0.0, 0.008, d));
        }
    }

    // 5. MORPHING SHAPE (circle â†” square)
    {
        vec2 p = uv - vec2(0.5, 0.25);
        p = rot2D(iTime * 0.5) * p;
        float t = sin(iTime) * 0.5 + 0.5;
        float d = mix(sdCircle(p, 0.1), sdBox(p, vec2(0.08)), t);
        vec3 c = mix(vec3(1.0,0.2,0.5), vec3(0.5,0.2,1.0), t);
        col = mix(col, c, 1.0 - smoothstep(0.0, 0.008, d));
    }

    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 5: Patterns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "05 â€” Patterns",
  short: "05 Pattern",
  tutorial: `
<h1>Patterns</h1>
<p class="subtitle">Repetition, grids, and tiling â€” complexity from simplicity</p>

<h2>ğŸ¯ The Secret</h2>
<p>Complex-looking shader art is usually just <strong>one shape repeated</strong>. The key operation is <code>fract()</code>.</p>

<h2>ğŸ” Domain Repetition</h2>
<pre>float freq = 8.0;
vec2 cell = fract(uv * freq) - 0.5;  // local coords
vec2 id   = floor(uv * freq);        // cell index</pre>
<p><code>cell</code> repeats -0.5â†’0.5 in every tile. <code>id</code> tells you which tile you're in (integers).</p>

<h2>ğŸ² Randomness Per Cell</h2>
<p>Use a hash function to give each cell a "random" value:</p>
<pre>float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}
float rnd = hash(id); // unique per cell!</pre>

<h2>ğŸ”µ Polar Repetition</h2>
<p>Repeat around a circle (kaleidoscope):</p>
<pre>float angle = atan(uv.y, uv.x);
float segments = 8.0;
angle = mod(angle, 6.28318/segments) - 3.14159/segments;</pre>

<h2>ğŸ§© Truchet Tiles</h2>
<p>Randomly flip tiles to create connected patterns â€” maze-like art from simple arcs!</p>

<div class="tip">The current code shows a basic grid. Read the comments to uncomment different sections and explore each pattern type!</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1</div>
<p>Change frequency from <code>8.0</code> to other values. See how the grid scales.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2 â€” Random Grid</div>
<p>Uncomment section 2 (Variation per cell) to see random sizes and colors.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 3 â€” Truchet</div>
<p>Uncomment section 5 (Truchet tiles) for a stunning connected pattern.</p>
</div>
  `,
  code: `// LESSON 05 â€” Patterns

float sdCircle(vec2 p, float r) { return length(p) - r; }
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}
mat2 rot2D(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }

float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    vec3 col = vec3(0.0);

    // â•â•â• Uncomment ONE section at a time â•â•â•

    // â€” 1. BASIC GRID â€”
    float freq = 8.0;
    vec2 cell = fract(uv * freq) - 0.5;
    vec2 id   = floor(uv * freq);
    float d = sdCircle(cell, 0.3);
    col = vec3(1.0 - smoothstep(0.0, 0.02, d));

    // â€” 2. RANDOM VARIATION â€”
    // float freq = 8.0;
    // vec2 cell = fract(uv * freq) - 0.5;
    // vec2 id   = floor(uv * freq);
    // float rnd = hash(id);
    // float d = sdCircle(cell, 0.1 + 0.2 * rnd);
    // vec3 cellCol = 0.5 + 0.5 * cos(vec3(0,2,4) + rnd * 6.28);
    // col = cellCol * (1.0 - smoothstep(0.0, 0.02, d));

    // â€” 3. ANIMATED GRID â€”
    // float freq = 6.0;
    // vec2 cell = fract(uv * freq + iTime * 0.3) - 0.5;
    // vec2 id   = floor(uv * freq + iTime * 0.3);
    // float rnd = hash(id);
    // cell = rot2D(iTime + rnd * 6.28) * cell;
    // float d = sdBox(cell, vec2(0.15 + 0.1*sin(iTime + rnd*6.28)));
    // vec3 cellCol = 0.5 + 0.5*cos(vec3(0,2,4) + rnd*6.28 + iTime);
    // col = cellCol * (1.0 - smoothstep(0.0, 0.02, d));

    // â€” 4. POLAR REPETITION (kaleidoscope) â€”
    // float angle = atan(uv.y, uv.x);
    // float radius = length(uv);
    // float segments = 8.0;
    // angle = mod(angle, 6.28318/segments) - 3.14159/segments;
    // vec2 p = vec2(cos(angle), sin(angle)) * radius;
    // float d = sdBox(p - vec2(0.3, 0.0), vec2(0.05, 0.02));
    // col = vec3(1.0, 0.5, 0.2) * (1.0 - smoothstep(0.0, 0.005, d));
    // d = abs(radius - 0.3) - 0.002;
    // col += vec3(0.2, 0.5, 1.0) * (1.0 - smoothstep(0.0, 0.005, d));

    // â€” 5. TRUCHET TILES â€”
    // float freq = 8.0;
    // vec2 cell = fract(uv * freq) - 0.5;
    // vec2 id   = floor(uv * freq);
    // if (hash(id) > 0.5) cell.x = -cell.x;
    // float d1 = abs(length(cell - vec2(0.5, 0.5)) - 0.5) - 0.05;
    // float d2 = abs(length(cell - vec2(-0.5,-0.5)) - 0.5) - 0.05;
    // float d = min(d1, d2);
    // col = vec3(0.9) * (1.0 - smoothstep(0.0, 0.01, d));
    // col += vec3(0.0, 0.3, 0.6) * exp(-4.0 * max(d, 0.0));

    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 6: Color â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "06 â€” Color Palettes",
  short: "06 Color",
  tutorial: `
<h1>Color Palettes</h1>
<p class="subtitle">The art of beautiful color in shaders</p>

<h2>ğŸ¯ The Cosine Palette</h2>
<p>Created by <strong>Inigo Quilez</strong> (Shadertoy's creator), this one formula generates infinite palettes:</p>
<pre>vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
    return a + b * cos(6.28318 * (c * t + d));
}</pre>
<p>Just 4 parameters: <strong>a</strong> = brightness, <strong>b</strong> = contrast, <strong>c</strong> = frequency, <strong>d</strong> = phase offset.</p>

<h2>ğŸ¨ Palette Presets</h2>
<table>
<tr><th>Name</th><th>d (phase)</th><th>Look</th></tr>
<tr><td>Rainbow</td><td><code>0.00, 0.33, 0.67</code></td><td>Full spectrum</td></tr>
<tr><td>Neon</td><td><code>0.00, 0.10, 0.20</code></td><td>Electric blue-pink</td></tr>
<tr><td>Fire</td><td><code>0.00, 0.15, 0.20</code></td><td>Warm orange-red</td></tr>
<tr><td>Ocean</td><td><code>0.50, 0.20, 0.25</code></td><td>Cool blue-green</td></tr>
</table>
<p>The <strong>d</strong> parameter is the most impactful â€” it controls the hue shift!</p>

<h2>ğŸŒˆ HSV Color Space</h2>
<p><strong>Hue</strong> (color wheel) + <strong>Saturation</strong> (vividness) + <strong>Value</strong> (brightness). Great for rainbows and UI.</p>

<h2>â˜€ï¸ Gamma Correction</h2>
<p>Screens aren't linear â€” apply this at the end for accurate colors:</p>
<pre>col = pow(col, vec3(0.4545)); // = 1/2.2</pre>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1 â€” Swap Palettes</div>
<p>Change the <code>d</code> vector in <code>coolPalette()</code> to the presets above.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2 â€” Palette + Pattern</div>
<p>Uncomment section 5 in the code for a mesmerizing fractal-palette combo.</p>
</div>
  `,
  code: `// LESSON 06 â€” Color Palettes

// IQ's cosine palette â€” the most important color function
vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
    return a + b * cos(6.28318 * (c * t + d));
}

// Preset: change the last vec3 to try different palettes!
vec3 coolPalette(float t) {
    return palette(t,
        vec3(0.5, 0.5, 0.5),
        vec3(0.5, 0.5, 0.5),
        vec3(1.0, 1.0, 1.0),
        vec3(0.00, 0.33, 0.67)  // â† try: (0.0,0.1,0.2) for neon
    );
}

// HSV to RGB
vec3 hsv2rgb(vec3 c) {
    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    vec3 col = vec3(0.0);

    // 1. Map distance through palette
    float dist = length(uv);
    col = coolPalette(dist - iTime * 0.4);

    // 2. Add animated concentric rings
    float rings = sin(dist * 40.0 - iTime * 5.0) * 0.5 + 0.5;
    rings = smoothstep(0.4, 0.6, rings);
    col *= 0.7 + 0.3 * rings;

    // 3. Rainbow wheel (uncomment to try):
    // float angle = atan(uv.y, uv.x) / 6.28318 + 0.5;
    // col = hsv2rgb(vec3(angle + iTime*0.1, 0.8, 0.9));

    // 5. FRACTAL PALETTE COMBO (uncomment to try):
    // vec2 p = uv;
    // float finalDist = 0.0;
    // for (float i = 0.0; i < 4.0; i++) {
    //     p = fract(p * 1.5) - 0.5;
    //     float d = length(p) * exp(-length(uv));
    //     finalDist += sin(d * 8.0 + iTime) / 8.0;
    // }
    // col = coolPalette(length(uv) + finalDist + iTime * 0.3);

    // Gamma correction
    col = pow(col, vec3(0.4545));

    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 7: Noise â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "07 â€” Noise",
  short: "07 Noise",
  tutorial: `
<h1>Noise</h1>
<p class="subtitle">The texture of nature â€” clouds, fire, terrain, organic shapes</p>

<h2>ğŸ¯ What is Noise?</h2>
<p>A function that returns smooth, random-looking values. Unlike <code>hash()</code> (which is choppy), noise transitions smoothly between values â€” perfect for natural-looking things.</p>

<h2>ğŸ—ï¸ How Value Noise Works</h2>
<ol>
  <li>Place random values at integer grid points</li>
  <li>For points between grid points, <strong>interpolate smoothly</strong></li>
  <li>Use a smooth curve (cubic hermite) for the interpolation</li>
</ol>
<pre>vec2 u = f * f * (3.0 - 2.0 * f); // smooth curve</pre>

<h2>ğŸŒŠ FBM â€” Fractal Brownian Motion</h2>
<p>Layer multiple <strong>octaves</strong> of noise at different scales:</p>
<pre>for (int i = 0; i < 6; i++) {
    value += amplitude * noise(p * frequency);
    frequency *= 2.0;   // finer detail each octave
    amplitude *= 0.5;   // less influence each octave
}</pre>
<p>Result: rich, detailed, natural patterns. The more octaves, the more detail.</p>

<h2>ğŸŒ€ Domain Warping</h2>
<p>Use noise to distort the input of MORE noise:</p>
<pre>vec2 q = vec2(fbm(p), fbm(p + vec2(5.2, 1.3)));
float result = fbm(p + 4.0 * q);</pre>
<p>This creates amazingly organic, alien-looking patterns.</p>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1 â€” FBM Clouds</div>
<p>Uncomment section 2 in the code to see cloud-like noise.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2 â€” Warped FBM</div>
<p>Uncomment section 3 for alien organic patterns.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 3 â€” Fire</div>
<p>Uncomment section 4 â€” scrolling FBM + warm colors = fire!</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 4 â€” Octave Count</div>
<p>Change the loop count in <code>fbm()</code> from 6 to 2 (smooth) or 10 (detailed).</p>
</div>
  `,
  code: `// LESSON 07 â€” Noise

float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

// Value Noise â€” smooth random values on a grid
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f); // smooth interpolation
    float a = hash(i + vec2(0,0));
    float b = hash(i + vec2(1,0));
    float c = hash(i + vec2(0,1));
    float d = hash(i + vec2(1,1));
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// FBM â€” Fractal Brownian Motion (layered noise)
float fbm(vec2 p) {
    float val = 0.0, amp = 0.5, freq = 1.0;
    for (int i = 0; i < 6; i++) {
        val += amp * noise(p * freq);
        freq *= 2.0;
        amp  *= 0.5;
        p += vec2(3.12, 7.53);
    }
    return val;
}

// Domain-warped FBM (organic alien shapes)
float warpedFbm(vec2 p) {
    vec2 q = vec2(fbm(p), fbm(p + vec2(5.2, 1.3)));
    vec2 r = vec2(
        fbm(p + 4.0*q + vec2(1.7,9.2) + 0.15*iTime),
        fbm(p + 4.0*q + vec2(8.3,2.8) + 0.126*iTime)
    );
    return fbm(p + 4.0 * r);
}

vec3 pal(float t) {
    return 0.5 + 0.5*cos(6.28318*(t + vec3(0.0, 0.33, 0.67)));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    vec3 col = vec3(0.0);

    // â•â•â• Uncomment ONE section â•â•â•

    // â€” 1. RAW NOISE â€”
    float n = noise(uv * 8.0 + iTime);
    col = vec3(n);

    // â€” 2. FBM CLOUDS â€”
    // float n = fbm(uv * 3.0 + iTime * 0.2);
    // col = mix(vec3(0.1, 0.2, 0.5), vec3(0.9, 0.9, 1.0), n);

    // â€” 3. WARPED FBM (alien) â€”
    // float n = warpedFbm(uv * 2.0);
    // col = pal(n + iTime * 0.1);

    // â€” 4. FIRE â€”
    // vec2 p = uv * 3.0;
    // p.y -= iTime * 0.5;
    // float n = fbm(p);
    // n = pow(n, 2.0);
    // col = mix(vec3(0.1,0,0), vec3(1.0,0.3,0.0), n);
    // col += vec3(1.0, 0.8, 0.2) * pow(n, 4.0);

    // â€” 5. NOISY SHAPE â€”
    // float d = length(uv) - 0.3;
    // float n = fbm(uv * 5.0 + iTime * 0.3);
    // d += n * 0.1;
    // col = mix(vec3(0.8,0.2,0.5), vec3(0.05), smoothstep(0.0, 0.02, d));
    // col += vec3(0.9,0.3,0.6) * exp(-6.0*max(d,0.0));

    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 8: Raymarching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "08 â€” Raymarching",
  short: "08 Raymarch",
  tutorial: `
<h1>Raymarching</h1>
<p class="subtitle">Entering the third dimension with sphere tracing</p>

<h2>ğŸ¯ The Big Idea</h2>
<p>Raymarching lets you render <strong>3D scenes entirely from math</strong>. No geometry, no meshes â€” just SDFs in 3D.</p>

<h2>ğŸ“ The Algorithm</h2>
<ol>
  <li>For each pixel, cast a <strong>ray</strong> from the camera</li>
  <li>March along the ray in steps</li>
  <li>At each step, ask the SDF: "how far am I from any surface?"</li>
  <li>Step forward by that distance (guaranteed safe!)</li>
  <li>If distance &lt; tiny epsilon â†’ <strong>HIT!</strong></li>
  <li>If total distance too far â†’ <strong>MISS</strong></li>
</ol>
<pre>for (int i = 0; i < MAX_STEPS; i++) {
    vec3 p = ro + rd * dist;
    float d = scene(p);
    if (d < EPSILON) break; // hit!
    dist += d;
    if (dist > MAX_DIST) break; // miss
}</pre>

<h2>ğŸ¥ Camera Setup</h2>
<pre>vec3 ro = vec3(0, 2, -5);           // ray origin (camera)
vec3 rd = normalize(vec3(uv, 1.0));  // ray direction</pre>
<p>The <code>1.0</code> in rd controls field of view (smaller = wider FOV).</p>

<h2>ğŸ“ 3D SDFs</h2>
<p>Same concept as 2D but with <code>vec3</code>:</p>
<pre>float sdSphere(vec3 p, float r) { return length(p) - r; }
float sdPlane(vec3 p)  { return p.y; } // y=0 plane</pre>

<h2>ğŸ” Computing Normals</h2>
<p>The normal = gradient of the SDF. We estimate it by sampling 6 nearby points:</p>
<pre>vec3 getNormal(vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(
        scene(p+e.xyy) - scene(p-e.xyy),
        scene(p+e.yxy) - scene(p-e.yxy),
        scene(p+e.yyx) - scene(p-e.yyx)
    ));
}</pre>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1</div>
<p>Change camera position <code>ro</code> â€” try <code>vec3(3, 1, -3)</code>.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2</div>
<p>Add a new sphere to the <code>scene()</code> function using <code>min()</code>.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 3</div>
<p>Try smooth union: replace <code>min()</code> with <code>smin()</code> (see lesson 09).</p>
</div>
  `,
  code: `// LESSON 08 â€” Raymarching: 3D from Pure Math

#define MAX_STEPS 100
#define MAX_DIST  100.0
#define EPSILON   0.001

float sdSphere(vec3 p, float r) { return length(p) - r; }
float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}
float sdPlane(vec3 p) { return p.y; }
float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

// The scene â€” combine all objects
float scene(vec3 p) {
    float ground = sdPlane(p + vec3(0, 1, 0));
    float sphere = sdSphere(p - vec3(0, 0.5+0.3*sin(iTime), 0), 0.5);

    vec3 bp = p - vec3(2, 0, 0);
    float a = iTime * 0.7;
    bp.xz = mat2(cos(a),-sin(a),sin(a),cos(a)) * bp.xz;
    float box = sdBox(bp, vec3(0.4));

    vec3 tp = p - vec3(-2, 0.3, 0);
    tp.xy = mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime)) * tp.xy;
    float torus = sdTorus(tp, vec2(0.5, 0.15));

    return min(ground, min(sphere, min(box, torus)));
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(EPSILON, 0.0);
    return normalize(vec3(
        scene(p+e.xyy)-scene(p-e.xyy),
        scene(p+e.yxy)-scene(p-e.yxy),
        scene(p+e.yyx)-scene(p-e.yyx)
    ));
}

float raymarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    for (int i = 0; i < MAX_STEPS; i++) {
        float d = scene(ro + rd * t);
        if (d < EPSILON) return t;
        t += d;
        if (t > MAX_DIST) break;
    }
    return -1.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;

    // Camera
    vec3 ro = vec3(0, 2, -5);
    vec3 rd = normalize(vec3(uv, 1.0));

    // Orbit camera
    float a = iTime * 0.3;
    ro.xz = mat2(cos(a),-sin(a),sin(a),cos(a)) * ro.xz;
    rd.xz = mat2(cos(a),-sin(a),sin(a),cos(a)) * rd.xz;

    float dist = raymarch(ro, rd);
    vec3 col = vec3(0.05, 0.05, 0.15);

    if (dist > 0.0) {
        vec3 p = ro + rd * dist;
        vec3 n = getNormal(p);
        vec3 lightDir = normalize(vec3(1, 1, -1));
        float diff = max(dot(n, lightDir), 0.0);
        float amb = 0.15;

        vec3 baseCol = vec3(0.8, 0.7, 0.6);
        if (p.y < -0.99) {
            float check = mod(floor(p.x)+floor(p.z), 2.0);
            baseCol = mix(vec3(0.3), vec3(0.7), check);
        }

        col = baseCol * (amb + diff * 0.85);
        col = mix(col, vec3(0.05,0.05,0.15), 1.0-exp(-0.05*dist*dist));
    }

    col = pow(col, vec3(0.4545));
    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 9: Lighting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "09 â€” Lighting",
  short: "09 Light",
  tutorial: `
<h1>Lighting</h1>
<p class="subtitle">Phong shading, soft shadows, and ambient occlusion</p>

<h2>ğŸ¯ Phong Lighting Model</h2>
<p>Three components that create convincing 3D lighting:</p>
<ul>
  <li><strong>Ambient</strong> â€” constant base light, prevents pure black</li>
  <li><strong>Diffuse</strong> â€” <code>max(dot(normal, lightDir), 0.0)</code> â€” how much surface faces the light</li>
  <li><strong>Specular</strong> â€” <code>pow(dot(half, normal), shininess)</code> â€” shiny highlight</li>
</ul>
<pre>col = baseColor * (ambient + diffuse * shadow)
    + specularColor * specular * shadow;</pre>

<h2>ğŸŒ˜ Soft Shadows</h2>
<p>March a ray from surface toward the light. Track the closest pass:</p>
<pre>result = min(result, k * d / t); // k = softness</pre>
<p>Lower <code>k</code> = softer shadows. This is one of raymarching's superpowers!</p>

<h2>ğŸ•³ï¸ Ambient Occlusion (AO)</h2>
<p>Step along the surface normal. If the SDF is less than expected, something is nearby â†’ darken.</p>
<pre>float dist = 0.05 * float(i);
float d = scene(p + normal * dist);
ao += weight * (dist - d);</pre>
<p>AO adds subtle darkening in crevices and corners â€” huge visual impact for cheap!</p>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 1 â€” Shadow Softness</div>
<p>Change the shadow <code>k</code> from <code>16.0</code> to <code>4.0</code> for much softer shadows.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 2 â€” Specular Power</div>
<p>Change <code>32.0</code> to <code>128.0</code> for tighter, shinier highlights.</p>
</div>

<div class="exercise">
<div class="exercise-title">ğŸ¨ Exercise 3 â€” Remove AO</div>
<p>Set <code>ao = 1.0</code> (no occlusion) to see what AO contributes.</p>
</div>
  `,
  code: `// LESSON 09 â€” Lighting: Phong, Shadows, AO

#define MAX_STEPS 100
#define MAX_DIST  50.0
#define EPSILON   0.001

float sdSphere(vec3 p, float r) { return length(p) - r; }
float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}
float smin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);
    return mix(b, a, h) - k*h*(1.0-h);
}

float scene(vec3 p) {
    float ground = p.y + 1.0;
    float s1 = sdSphere(p - vec3(0, 0.5+0.2*sin(iTime*1.5), 0), 0.6);
    float s2 = sdSphere(p - vec3(0.8*sin(iTime), 0.3, 0.8*cos(iTime)), 0.35);
    float s3 = sdSphere(p - vec3(-0.7*cos(iTime*0.7), 0.4, 0.5*sin(iTime*0.9)), 0.3);
    float blob = smin(smin(s1, s2, 0.5), s3, 0.5);
    return min(ground, blob);
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(EPSILON, 0.0);
    return normalize(vec3(
        scene(p+e.xyy)-scene(p-e.xyy),
        scene(p+e.yxy)-scene(p-e.yxy),
        scene(p+e.yyx)-scene(p-e.yyx)
    ));
}

float raymarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    for (int i = 0; i < MAX_STEPS; i++) {
        float d = scene(ro + rd * t);
        if (d < EPSILON) return t;
        t += d;
        if (t > MAX_DIST) break;
    }
    return -1.0;
}

// Soft shadows â€” k controls softness
float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
    float res = 1.0;
    float t = mint;
    for (int i = 0; i < 64; i++) {
        float d = scene(ro + rd * t);
        if (d < EPSILON) return 0.0;
        res = min(res, k * d / t);
        t += clamp(d, 0.02, 0.2);
        if (t > maxt) break;
    }
    return clamp(res, 0.0, 1.0);
}

// Ambient Occlusion
float calcAO(vec3 p, vec3 n) {
    float ao = 0.0, w = 1.0;
    for (int i = 1; i <= 5; i++) {
        float d = 0.05 * float(i);
        ao += w * (d - scene(p + n * d));
        w *= 0.5;
    }
    return clamp(1.0 - 3.0 * ao, 0.0, 1.0);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;

    vec3 ro = vec3(0, 2, -4);
    vec3 rd = normalize(vec3(uv, 1.2));
    float a = iTime * 0.25;
    ro.xz = mat2(cos(a),-sin(a),sin(a),cos(a)) * ro.xz;
    rd.xz = mat2(cos(a),-sin(a),sin(a),cos(a)) * rd.xz;

    vec3 col = mix(vec3(0.1,0.1,0.2), vec3(0.4,0.5,0.8), uv.y+0.5);
    float dist = raymarch(ro, rd);

    if (dist > 0.0) {
        vec3 p = ro + rd * dist;
        vec3 n = getNormal(p);

        // Material
        vec3 baseCol = (p.y < -0.99)
            ? mix(vec3(0.15), vec3(0.4), mod(floor(p.x)+floor(p.z), 2.0))
            : 0.5 + 0.5 * n;

        // Phong lighting
        vec3 lightDir = normalize(vec3(3, 5, -2) - p);
        vec3 halfDir  = normalize(lightDir + normalize(ro - p));
        float diff    = max(dot(n, lightDir), 0.0);
        float spec    = pow(max(dot(n, halfDir), 0.0), 32.0);
        float shadow  = softShadow(p + n*0.01, lightDir, 0.02, 10.0, 16.0);
        float ao      = calcAO(p, n);

        col = baseCol * (0.08 + diff * shadow * 0.9) * ao;
        col += vec3(1, 0.95, 0.9) * spec * shadow * 0.5;
        col = mix(col, vec3(0.1,0.1,0.2), 1.0-exp(-0.04*dist*dist));
    }

    col = pow(col, vec3(0.4545));
    col *= 1.0 - 0.3 * length(uv);
    fragColor = vec4(col, 1.0);
}`
},

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LESSON 10: Advanced SDF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{
  title: "10 â€” Advanced SDF",
  short: "10 Advanced",
  tutorial: `
<h1>Advanced SDF Techniques</h1>
<p class="subtitle">Smooth booleans, domain ops, and putting it all together</p>

<h2>ğŸ”— Smooth Boolean Operators</h2>
<pre>// Smooth union â€” blobs, metaballs, organic
float smin(float a, float b, float k) {
    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
    return mix(b,a,h) - k*h*(1.0-h);
}
// Smooth subtraction: smax(a, -b, k)
// Smooth intersection: smax(a, b, k)</pre>

<h2>ğŸ”§ SDF Modifiers</h2>
<table>
<tr><th>Modifier</th><th>Code</th><th>Effect</th></tr>
<tr><td>Round</td><td><code>sdf - r</code></td><td>Round all edges</td></tr>
<tr><td>Onion</td><td><code>abs(sdf) - t</code></td><td>Hollow shell</td></tr>
<tr><td>Twist</td><td>Rotate xz by y</td><td>Spiral deformation</td></tr>
<tr><td>Repeat</td><td><code>mod(p, period)</code></td><td>Infinite copies</td></tr>
</table>

<h2>â™¾ï¸ Infinite Repetition</h2>
<pre>vec3 opRep(vec3 p, vec3 period) {
    return mod(p + 0.5*period, period) - 0.5*period;
}</pre>
<p>One SDF becomes an infinite field!</p>

<h2>ğŸŒ€ Twist Deformation</h2>
<pre>float c = cos(amount * p.y);
float s = sin(amount * p.y);
p.xz = mat2(c,-s,s,c) * p.xz;</pre>

<h2>âœ¨ Post-Processing</h2>
<ul>
  <li><strong>Gamma:</strong> <code>pow(col, vec3(0.4545))</code></li>
  <li><strong>Vignette:</strong> <code>col *= 1.0 - 0.4 * length(uv)Â²</code></li>
  <li><strong>Rim light:</strong> <code>pow(1.0 - dot(n, viewDir), 3.0)</code></li>
</ul>

<h2>ğŸš€ Where to Go Next</h2>
<ul>
  <li><a href="https://shadertoy.com" target="_blank" style="color:var(--accent)">Shadertoy.com</a> â€” thousands of shaders to study and remix</li>
  <li><a href="https://iquilezles.org/articles/" target="_blank" style="color:var(--accent)">iquilezles.org</a> â€” Inigo Quilez's SDF bible</li>
  <li><a href="https://thebookofshaders.com" target="_blank" style="color:var(--accent)">The Book of Shaders</a> â€” beautiful interactive GLSL textbook</li>
  <li><a href="https://youtube.com/@TheArtOfCode" target="_blank" style="color:var(--accent)">The Art of Code</a> (YouTube) â€” excellent tutorials</li>
  <li><a href="https://youtube.com/@InigoQuilez" target="_blank" style="color:var(--accent)">Inigo Quilez</a> (YouTube) â€” the master himself</li>
</ul>

<div class="tip">You now have all the building blocks. The rest is practice, experimentation, and studying other people's shaders. Copy shaders from Shadertoy, paste them here, break them apart, and rebuild them. That's how you learn!</div>
  `,
  code: `// LESSON 10 â€” Advanced SDF: The Full Toolkit

#define MAX_STEPS 150
#define MAX_DIST  80.0
#define EPSILON   0.0005

float sdSphere(vec3 p, float r) { return length(p) - r; }
float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}
float sdTorus(vec3 p, vec2 t) {
    return length(vec2(length(p.xz)-t.x, p.y)) - t.y;
}
float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
float sdOctahedron(vec3 p, float s) {
    p = abs(p);
    return (p.x+p.y+p.z-s)*0.57735027;
}
float smin(float a, float b, float k) {
    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
    return mix(b,a,h) - k*h*(1.0-h);
}

vec3 opRep(vec3 p, vec3 c) {
    return mod(p+0.5*c, c) - 0.5*c;
}

vec3 opTwist(vec3 p, float k) {
    float c = cos(k*p.y), s = sin(k*p.y);
    p.xz = mat2(c,-s,s,c) * p.xz;
    return p;
}

float scene(vec3 p) {
    float ground = p.y + 1.0;

    // Twisted hollow box
    vec3 p1 = p - vec3(0, 0.5, 0);
    float a = iTime * 0.4;
    p1.xz = mat2(cos(a),-sin(a),sin(a),cos(a)) * p1.xz;
    p1 = opTwist(p1, 2.0 + sin(iTime*0.5));
    float box = sdBox(p1, vec3(0.5, 0.8, 0.5));
    box = abs(box) - 0.05; // onion (hollow)
    box -= 0.01;           // round edges

    // Orbiting blobs
    float spheres = MAX_DIST;
    for (float i = 0.0; i < 5.0; i++) {
        float ang = iTime*0.8 + i*6.28318/5.0;
        vec3 sp = p - vec3(1.2*cos(ang), 0.5+0.3*sin(iTime*2.0+i), 1.2*sin(ang));
        spheres = smin(spheres, sdSphere(sp, 0.2), 0.3);
    }
    float center = smin(box, spheres, 0.2);

    // Pillars
    vec3 rp = opRep(p, vec3(4, 0, 4));
    float pillars = sdCylinder(rp, 2.0, 0.15);
    vec3 cell = floor((p+vec3(2,0,2))/vec3(4,1,4));
    if (abs(cell.x)<0.5 && abs(cell.z)<0.5) pillars = MAX_DIST;

    // Floating octahedron
    vec3 op = p - vec3(0, 3.0+0.5*sin(iTime), 0);
    a = iTime * 0.6;
    op.xz = mat2(cos(a),-sin(a),sin(a),cos(a)) * op.xz;
    op.xy = mat2(cos(a*0.7),-sin(a*0.7),sin(a*0.7),cos(a*0.7)) * op.xy;
    float octa = sdOctahedron(op, 0.4);

    return min(ground, min(center, min(pillars, octa)));
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(EPSILON, 0);
    return normalize(vec3(scene(p+e.xyy)-scene(p-e.xyy),
                          scene(p+e.yxy)-scene(p-e.yxy),
                          scene(p+e.yyx)-scene(p-e.yyx)));
}
float raymarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    for (int i = 0; i < MAX_STEPS; i++) {
        float d = scene(ro+rd*t);
        if (d < EPSILON) return t;
        t += d;
        if (t > MAX_DIST) break;
    }
    return -1.0;
}
float softShadow(vec3 ro, vec3 rd, float mi, float ma, float k) {
    float res=1.0, t=mi;
    for (int i=0; i<48; i++) {
        float d=scene(ro+rd*t);
        if(d<EPSILON) return 0.0;
        res=min(res,k*d/t);
        t+=clamp(d,0.01,0.2);
        if(t>ma) break;
    }
    return clamp(res,0.0,1.0);
}
float calcAO(vec3 p, vec3 n) {
    float ao=0.0, w=1.0;
    for(int i=1;i<=5;i++){float d=0.04*float(i);ao+=w*(d-scene(p+n*d));w*=0.5;}
    return clamp(1.0-4.0*ao,0.0,1.0);
}
vec3 pal(float t) {
    return 0.5+0.5*cos(6.28*(vec3(1,.7,.4)*t+vec3(0,.15,.2)));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;
    float ca = iTime*0.2;
    vec3 ro = vec3(5.0*sin(ca), 2.5+sin(iTime*0.3), 5.0*cos(ca));
    vec3 target = vec3(0, 0.8, 0);
    vec3 fwd = normalize(target-ro);
    vec3 right = normalize(cross(vec3(0,1,0), fwd));
    vec3 up = cross(fwd, right);
    vec3 rd = normalize(fwd + uv.x*right + uv.y*up);

    vec3 col = mix(vec3(0.02,0.02,0.08), vec3(0.15,0.1,0.3), uv.y+0.5);
    float dist = raymarch(ro, rd);

    if (dist > 0.0) {
        vec3 p = ro + rd*dist, n = getNormal(p);
        vec3 baseCol = (p.y<-0.99)
            ? mix(vec3(0.08),vec3(0.2),mod(floor(p.x*0.5)+floor(p.z*0.5),2.0))
            : pal(p.y*0.3 + length(p.xz)*0.1 + iTime*0.1);
        vec3 ld = normalize(vec3(2,4,-1));
        float diff = max(dot(n,ld),0.0);
        float spec = pow(max(dot(reflect(-ld,n),normalize(ro-p)),0.0),64.0);
        float sh = softShadow(p+n*0.02,ld,0.05,15.0,12.0);
        float ao = calcAO(p,n);
        col = baseCol*(0.06+diff*sh*0.85)*ao + vec3(1,.9,.8)*spec*sh*0.6;
        float rim = pow(1.0-max(dot(n,normalize(ro-p)),0.0),3.0);
        col += vec3(0.3,0.1,0.5)*rim*0.5;
        col = mix(col, vec3(0.02,0.02,0.08), 1.0-exp(-0.008*dist*dist));
    }

    col = pow(col, vec3(0.4545));
    col *= 1.0 - 0.4*pow(length(uv),2.0);
    fragColor = vec4(col, 1.0);
}`
}
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WebGL Engine (Shadertoy-compatible)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas   = document.getElementById('glcanvas');
const gl       = canvas.getContext('webgl2') || canvas.getContext('webgl');
const editor   = document.getElementById('shader-code');
const errorBar = document.getElementById('error-bar');

if (!gl) alert('WebGL not supported in this browser!');

const isWebGL2 = gl instanceof WebGL2RenderingContext;

const VERT_SRC = isWebGL2
  ? `#version 300 es\nprecision highp float;\nin vec2 a_pos;\nvoid main(){gl_Position=vec4(a_pos,0,1);}`
  : `attribute vec2 a_pos;\nvoid main(){gl_Position=vec4(a_pos,0,1);}`;

function wrapFrag(code) {
  if (isWebGL2) return `#version 300 es
precision highp float;
uniform vec3 iResolution;uniform float iTime;uniform float iTimeDelta;uniform int iFrame;uniform vec4 iMouse;
out vec4 _fc;
${code}
void main(){vec4 c=vec4(0);mainImage(c,gl_FragCoord.xy);_fc=c;}`;
  return `precision highp float;
uniform vec3 iResolution;uniform float iTime;uniform float iTimeDelta;uniform int iFrame;uniform vec4 iMouse;
${code}
void main(){vec4 c=vec4(0);mainImage(c,gl_FragCoord.xy);gl_FragColor=c;}`;
}

function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src); gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { const l=gl.getShaderInfoLog(s); gl.deleteShader(s); throw l; }
  return s;
}
function link(v, f) {
  const p = gl.createProgram();
  gl.attachShader(p,v); gl.attachShader(p,f); gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) { const l=gl.getProgramInfoLog(p); gl.deleteProgram(p); throw l; }
  return p;
}

const qb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, qb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);

let prog = null, unis = {}, startT = performance.now()/1e3, lastT = startT, frame = 0;
let paused = false, pauseT = 0;
let mouse = {x:0,y:0,cx:0,cy:0,down:false};

canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left; mouse.y = r.height - (e.clientY - r.top);
  document.getElementById('hud-mouse').textContent = `${mouse.x.toFixed(0)}, ${mouse.y.toFixed(0)}`;
});
canvas.addEventListener('mousedown', e => { mouse.down=true; const r=canvas.getBoundingClientRect(); mouse.cx=e.clientX-r.left; mouse.cy=r.height-(e.clientY-r.top); });
canvas.addEventListener('mouseup', () => mouse.down=false);

function buildShader(code) {
  errorBar.style.display = 'none';
  try {
    const vs = compile(gl.VERTEX_SHADER, VERT_SRC);
    const fs = compile(gl.FRAGMENT_SHADER, wrapFrag(code));
    const p = link(vs, fs);
    if (prog) gl.deleteProgram(prog);
    prog = p;
    gl.useProgram(prog);
    unis = {
      iResolution: gl.getUniformLocation(p,'iResolution'),
      iTime:       gl.getUniformLocation(p,'iTime'),
      iTimeDelta:  gl.getUniformLocation(p,'iTimeDelta'),
      iFrame:      gl.getUniformLocation(p,'iFrame'),
      iMouse:      gl.getUniformLocation(p,'iMouse'),
    };
    const a = gl.getAttribLocation(p,'a_pos');
    gl.bindBuffer(gl.ARRAY_BUFFER, qb);
    gl.enableVertexAttribArray(a);
    gl.vertexAttribPointer(a,2,gl.FLOAT,false,0,0);
    startT = performance.now()/1e3; frame = 0;
  } catch(e) {
    errorBar.textContent = 'âš  ' + e;
    errorBar.style.display = 'block';
  }
}

let fpsSamples = [];
function render() {
  requestAnimationFrame(render);
  if (!prog) return;
  const panel = document.getElementById('canvas-area');
  const bar   = document.getElementById('canvas-bar');
  const w = Math.floor(panel.clientWidth);
  const h = Math.floor(panel.clientHeight - bar.offsetHeight);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    gl.viewport(0,0,w,h);
    document.getElementById('hud-res').textContent = `${w}Ã—${h}`;
  }
  const now = performance.now()/1e3;
  if (paused) { startT += (now - pauseT); pauseT = now; }
  const time = paused ? 0 : now - startT;
  const dt = now - lastT; lastT = now;
  fpsSamples.push(dt); if (fpsSamples.length > 30) fpsSamples.shift();
  const avg = fpsSamples.reduce((a,b)=>a+b)/fpsSamples.length;
  document.getElementById('hud-fps').textContent = (1/avg).toFixed(0);
  document.getElementById('hud-time').textContent = time.toFixed(2);

  gl.useProgram(prog);
  if(unis.iResolution) gl.uniform3f(unis.iResolution,w,h,1);
  if(unis.iTime) gl.uniform1f(unis.iTime,time);
  if(unis.iTimeDelta) gl.uniform1f(unis.iTimeDelta,dt);
  if(unis.iFrame) gl.uniform1i(unis.iFrame,frame);
  if(unis.iMouse) gl.uniform4f(unis.iMouse,
    mouse.down?mouse.x:mouse.cx, mouse.down?mouse.y:mouse.cy,
    mouse.down?mouse.cx:-mouse.cx, mouse.down?mouse.cy:-mouse.cy);
  gl.drawArrays(gl.TRIANGLES,0,6);
  frame++;
}
requestAnimationFrame(render);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI: Lesson Navigation + Tutorial Panel
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let currentLesson = 0;
const completed = new Set();

// Populate dropdown
const select = document.getElementById('lesson-select');
LESSONS.forEach((l,i) => {
  const opt = document.createElement('option');
  opt.value = i; opt.textContent = l.title;
  select.appendChild(opt);
});

// Populate pills
const pillsContainer = document.getElementById('lesson-pills');
function renderPills() {
  pillsContainer.innerHTML = '';
  LESSONS.forEach((l,i) => {
    const pill = document.createElement('span');
    pill.className = 'pill' + (i === currentLesson ? ' active' : '') + (completed.has(i) && i !== currentLesson ? ' completed' : '');
    pill.textContent = l.short;
    pill.addEventListener('click', () => loadLesson(i));
    pillsContainer.appendChild(pill);
  });
}

function loadLesson(index) {
  if (currentLesson !== index && currentLesson >= 0) completed.add(currentLesson);
  currentLesson = index;
  const lesson = LESSONS[index];

  // Update code editor
  editor.value = lesson.code;
  buildShader(lesson.code);
  document.getElementById('tab-filename').textContent = lesson.title.replace(/^\\d+\\s*â€”\\s*/, '') + '.glsl';

  // Update tutorial
  document.getElementById('tutorial-content').innerHTML = lesson.tutorial;

  // Update nav
  select.value = index;
  renderPills();

  // Scroll tutorial to top
  document.getElementById('tutorial-body').scrollTop = 0;
}

select.addEventListener('change', () => loadLesson(parseInt(select.value)));

// â”€â”€ Tutorial toggle â”€â”€
const tutPanel = document.getElementById('tutorial-panel');
const btnTut   = document.getElementById('btn-tutorial');
function toggleTutorial(show) {
  const isVisible = !tutPanel.classList.contains('hidden');
  const shouldShow = show !== undefined ? show : !isVisible;
  tutPanel.classList.toggle('hidden', !shouldShow);
  btnTut.classList.toggle('active', shouldShow);
}
btnTut.addEventListener('click', () => toggleTutorial());
document.getElementById('btn-close-tutorial').addEventListener('click', () => toggleTutorial(false));

// â”€â”€ Compile / Pause / Reset â”€â”€
document.getElementById('btn-compile').addEventListener('click', () => buildShader(editor.value));
document.getElementById('btn-pause').addEventListener('click', function() {
  paused = !paused;
  if (paused) pauseT = performance.now()/1e3;
  this.textContent = paused ? 'â–¶ Resume' : 'â¸ Pause';
});
document.getElementById('btn-reset').addEventListener('click', () => {
  startT = performance.now()/1e3; frame = 0;
});

// â”€â”€ Keyboard shortcuts â”€â”€
editor.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'Enter') { e.preventDefault(); buildShader(editor.value); }
  if (e.key === 'Tab') {
    e.preventDefault();
    const s = editor.selectionStart, end = editor.selectionEnd;
    editor.value = editor.value.substring(0,s) + '    ' + editor.value.substring(end);
    editor.selectionStart = editor.selectionEnd = s + 4;
  }
});
document.addEventListener('keydown', e => {
  if (e.key === 't' && !e.ctrlKey && document.activeElement !== editor) toggleTutorial();
});

// â”€â”€ Resizer for editor â†” canvas split â”€â”€
const resizer = document.getElementById('resizer');
const editorArea = document.getElementById('editor-area');
const canvasArea = document.getElementById('canvas-area');
let isResizing = false;
resizer.addEventListener('mousedown', e => { isResizing = true; resizer.classList.add('active'); e.preventDefault(); });
document.addEventListener('mousemove', e => {
  if (!isResizing) return;
  const split = document.getElementById('workspace-split');
  const rect = split.getBoundingClientRect();
  const tutRect = tutPanel.classList.contains('hidden') ? {width:0} : tutPanel.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const total = rect.width;
  const pct = Math.max(20, Math.min(80, (x / total) * 100));
  editorArea.style.flex = 'none';
  editorArea.style.width = pct + '%';
  canvasArea.style.flex = '1';
});
document.addEventListener('mouseup', () => { isResizing = false; resizer.classList.remove('active'); });

// â”€â”€ Load first lesson â”€â”€
loadLesson(0);
renderPills();
</script>
</body>
</html>
